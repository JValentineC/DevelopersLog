{
  "title": "Underworld Dev Log",
  "header": {
    "headerTitle": "Building Underworld ‚Äî A Pygame Journey",
    "welcomeMessage": "Welcome to my development log for Underworld, a top-down game built with Python and Pygame. Here I document each session ‚Äî what I built, what I learned, and how I used AI as a tutor along the way.",
    "checkBackMessage": "New sessions are added as the project evolves. Check back for the latest progress."
  },

  "mainContent": {
    "mainTitle": "Development Log",
    "logEntries": [
      {
        "entryTitle": "Session 1: Foundation Loop and Debug HUD",
        "date": "2026-02-13",
        "entryNumber": 1,
        "author": "Jonathan Ramirez",
        "content": [
          "<strong>Phase 1 kicks off!</strong> This session I created the foundational game loop and a debug HUD for <em>Underworld</em>.",
          
          "<strong>Files created:</strong><ul><li><code>test_window.py</code> ‚Äî Throwaway pygame test</li><li><code>setting.py</code> ‚Äî Constants for screen size, FPS, tile size, colors</li><li><code>src/game_state.py</code> ‚Äî GameState and MovementMode enums</li><li><code>main.py</code> ‚Äî Real game loop with debug HUD and F3 toggle</li></ul>",
          
          "<strong>What works:</strong> Window opens at 640√ó480 with the title <em>Underworld</em>. Game loop runs at a stable 60 FPS. Debug overlay shows FPS, current GameState, and MovementMode. <code>F3</code> toggles the overlay on/off. Escape and the X button close the game cleanly.",
          
          "<hr>",
          
          "<strong>Python concepts learned:</strong><ul><li><strong>Modules and imports</strong> for code organization</li><li><strong>ALL_CAPS naming conventions</strong> for constants</li><li><strong>Enums</strong> for type-safe state management</li><li><strong>Boolean toggle pattern</strong> ‚Äî <code>show_debug = not show_debug</code></li><li><strong>f-strings</strong> for formatted output</li><li><strong>Tuples</strong> for colors and coordinates</li></ul>",
          
          "<strong>Pygame concepts learned:</strong><ul><li>The game loop pattern: <strong>Events ‚Üí Update ‚Üí Draw</strong></li><li><code>pygame.init()</code>, Surfaces and <code>blit()</code></li><li><code>display.set_mode()</code> and <code>display.flip()</code> for double buffering</li><li><code>Clock.tick(FPS)</code> for frame-rate capping and delta time</li><li><code>clock.get_fps()</code> for measuring real FPS</li><li>Event handling with <code>pygame.event.get()</code></li><li><code>pygame.font.SysFont()</code> for text rendering</li><li><code>screen.fill()</code> to clear each frame</li></ul>",
          
          "<strong>How I used AI:</strong> I started with a throwaway test file to confirm pygame worked before touching the real project. I asked for explanations, not just code. I requested heavily commented code so every file doubles as a reference document. AI followed an incremental plan ‚Äî test file ‚Üí settings ‚Üí enums ‚Üí main.py ‚Äî each step testable. After AI set up the GameState enum, I added <code>DEV_MENU</code> on my own.",
          
          "<blockquote>Key takeaway: Having a session plan kept the work focused. Asking 'what are my options' before 'write the code' built real understanding. Running code frequently caught problems early.</blockquote>"
        ]
      },
      {
        "entryTitle": "Session 2: Tilemap Room Rendering and Wall Colliders",
        "date": "2026-02-13",
        "entryNumber": 2,
        "author": "Jonathan Ramirez",
        "content": [
          "<strong>Session 2 brings the world to life</strong> ‚Äî tilemap-based rooms with wall collision rectangles.",
          
          "<strong>Files created or modified:</strong><ul><li><code>setting.py</code> ‚Äî Added floor/wall colors, directional wall colors, WALL_CHARS set, TILE_COLOR_MAP dict</li><li><code>src/room.py</code> ‚Äî Room class + load_tilemap() helper</li><li><code>assets/rooms/room_01.txt</code> through <code>room_04.txt</code> ‚Äî Hand-authored room templates</li><li><code>main.py</code> ‚Äî Wired Room into the draw phase</li></ul>",
          
          "<strong>What works:</strong> Room loads from a <code>.txt</code> tilemap file. Six tile characters recognized:<ul><li><code>'.'</code> floor</li><li><code>'#'</code> interior wall</li><li><code>'-'</code> north wall</li><li><code>'_'</code> south wall</li><li><code>'['</code> west wall</li><li><code>']'</code> east wall</li></ul>Each wall direction renders in a distinct placeholder color. All wall types generate collision rects. Red debug outlines show collision rects toggled with <code>F3</code>. Four room templates tested at different sizes (20√ó15, 40√ó15, 40√ó30).",
          
          "<hr>",
          
          "<strong>Python concepts learned:</strong><ul><li><strong>Classes and __init__</strong> for bundling data and behavior</li><li><strong>Lists of strings as a 2D grid</strong> for tilemaps</li><li><strong>Nested loops</strong> for iterating rows and columns</li><li><strong>List comprehensions</strong> for compact data transforms</li><li><strong>File I/O with 'with open()'</strong> context managers</li><li><strong>Private methods</strong> via underscore convention</li><li><strong>Sets</strong> for fast membership testing</li><li><strong>Dictionaries</strong> for key-value mapping</li><li><strong>Data-driven design</strong> to replace if/elif chains</li></ul>",
          
          "<strong>Pygame concepts learned:</strong><ul><li><code>pygame.Rect</code> for positioning and collision detection</li><li><code>pygame.draw.rect()</code> for placeholder tile rendering</li><li><strong>Drawing order:</strong> floors first, walls on top, debug last</li><li><strong>Grid-to-pixel conversion:</strong> <code>x = col * TILE_SIZE</code></li></ul>",
          
          "<strong>How I used AI:</strong> AI created Room with a basic wall color ‚Äî I then added directional wall colors on my own. I proposed different characters for wall directions and designed <code>room_02.txt</code> myself before AI wired it into the engine. AI formalized my experiment into <code>WALL_CHARS + TILE_COLOR_MAP</code>, turning it into a scalable data-driven system.",
          
          "<blockquote>When I renamed WALL_COLOR, Python's ImportError in room.py taught me why named imports catch bugs fast.</blockquote>"
        ]
      },
      {
        "entryTitle": "Phase 2 Bonus: Room Templates, Room Switching, New Tile Types",
        "date": "2026-02-14",
        "entryNumber": 3,
        "author": "Jonathan Ramirez",
        "content": [
          "<strong>Bonus work</strong> between Session 2 and Session 3 to strengthen the foundation before adding the player.",
          
          "<strong>Built 11 new themed room templates</strong> (rooms 05‚Äì15): arenas, mazes, nested rooms, pillar layouts, zigzag grids, prison cells, bedrooms, shops, dungeon cells, and barracks. All 15 rooms validated with a custom diagnostic script (<code>check_rooms.py</code>).",
          
          "<strong>New features added:</strong><ul><li>Room switching with Left/Right arrows and modulo wrapping</li><li>Debug HUD now shows 'Room: 3/15'</li><li>Three new tile characters:<ul><li><code>'+'</code> corner wall (pinkish)</li><li><code>'S'</code> spawn marker (bright green)</li><li><code>'D'</code> door marker (purple)</li></ul></li><li>Room class now exposes <code>self.spawn_point</code> as a pixel-center tuple</li><li>Room class exposes <code>self.door_rects</code> as a list of pygame.Rect objects</li><li>Debug overlay enhanced with wall outlines (red), door outlines (blue), and spawn circle (green)</li></ul>",
          
          "<hr>",
          
          "<strong>Python concepts learned:</strong><ul><li><strong>List comprehensions for path generation</strong> with f-string formatting (<code>:02d</code> for zero-padded numbers)</li><li><strong>Modulo wrapping</strong> for cycling through rooms</li><li><strong>Helper functions</strong> to avoid code duplication</li><li><strong>Assertions</strong> for data validation</li><li><strong>Tuple return values</strong></li><li><strong>None</strong> as a sentinel for 'no value'</li></ul>",
          
          "<strong>üêõ Debugging lesson ‚Äî Inconsistent Line Lengths:</strong> When room switching was added, the game crashed with <code>IndexError: string index out of range</code> inside <code>_build_wall_rects()</code>. Several room files had lines shorter than the first line's width.",
          
          "<strong>Root causes found:</strong><ul><li>Trailing blank lines</li><li>Off-by-one padding</li><li>Concatenated lines from missing newlines</li></ul>",
          
          "<strong>Fix:</strong> Built <code>check_rooms.py</code> to diagnose all 15 rooms, fixed each one, and re-validated.",
          
          "<blockquote>Takeaway: When authoring grid-based text data by hand, always build a validation tool ‚Äî don't trust your eyes.</blockquote>",
          
          "<strong>How I used AI:</strong> I described room themes and AI generated tilemap layouts. When the IndexError hit, AI created a diagnostic tool first instead of guessing at a fix ‚Äî teaching me to <em>measure before fixing</em>. AI also wrote a throwaway script to batch-update all 15 room files ‚Äî teaching me that throwaway automation beats tedious manual edits."
        ]
      },
      {
        "entryTitle": "Session 3: Player Rect Movement with Collision",
        "date": "2026-02-14",
        "entryNumber": 4,
        "author": "Jonathan Ramirez",
        "content": [
          "<strong>The player enters the world!</strong> Top-down movement with axis-separated collision resolution.",
          
          "<img src=\"assets/Screenshot 2026-02-14 143518.png\" alt=\"Underworld game screenshot showing player movement and collision\">",
          
          "<strong>Files created or modified:</strong><ul><li><code>src/player.py</code> ‚Äî New Player class with rect, speed, input handling, axis-separated collision, draw and draw_debug methods</li><li><code>setting.py</code> ‚Äî Added PLAYER_SIZE=24, PLAYER_SPEED=200, PLAYER_COLOR=cyan</li><li><code>main.py</code> ‚Äî Imported Player, spawned at room's 'S' tile, wired update/draw/draw_debug into game loop, moved room cycling to Page Up/Page Down</li></ul>",
          
          "<strong>What works:</strong><ul><li>Player spawns at the room's <code>'S'</code> tile</li><li>WASD and arrow keys move the player in 4/8 directions</li><li>Player collides with all wall types and slides smoothly along them</li><li>Diagonal movement is normalized (same speed in all directions)</li><li>Player is a 24√ó24 cyan rectangle (smaller than a 32px tile for corridor clearance)</li><li>Debug overlay shows cyan outline around the player collision rect</li><li>Page Up/Page Down cycle rooms with player re-spawn</li><li>No sticking, no jitter, no pass-through</li></ul>",
          
          "<hr>",
          
          "<strong>Python concepts learned:</strong><ul><li>The <code>math</code> module and <code>math.hypot()</code> for vector length</li><li><strong>Vector normalization</strong> to ensure consistent diagonal speed:<ul><li>Without: diagonal = 200 √ó ‚àö2 ‚âà 283 px/sec</li><li>With: diagonal = 200 √ó 1 = 200 px/sec</li></ul></li><li>The <code>*</code> unpacking operator for splatting tuples into arguments</li><li><strong>Separation of concerns</strong> ‚Äî Player knows nothing about rooms or game state</li><li>Mutable Rect objects that keep position and collision box in sync</li><li>Augmented assignment <code>+=</code> for readable movement code</li></ul>",
          
          "<strong>Pygame concepts learned:</strong><ul><li><code>pygame.key.get_pressed()</code> for continuous held-key input vs KEYDOWN for one-shot events</li><li><code>pygame.Rect</code> positioning shortcuts: <code>center</code>, <code>right</code>, <code>bottom</code>, <code>topleft</code>, <code>midbottom</code></li><li><code>rect.colliderect()</code> for overlap detection</li><li>Collision resolution by snapping edges: <code>self.rect.right = wall.left</code></li><li>Drawing order: room ‚Üí player ‚Üí debug</li></ul>",
          
          "<strong>üéØ Key design decision ‚Äî Axis-Separated Collision:</strong> Moving both axes at once makes it ambiguous whether to push out horizontally or vertically, causing corner sticking, wall teleporting, and jittery corrections.",
          
          "<strong>The two-pass solution:</strong><ol><li>Move X, resolve horizontal overlaps</li><li>Move Y, resolve vertical overlaps</li></ol>Each pass has unambiguous resolution.",
          
          "<strong>Result:</strong> Smooth wall sliding without getting stuck on corners.",
          
          "<strong>üéØ Key design decision ‚Äî Player Size < Tile Size:</strong> <code>PLAYER_SIZE=24</code> vs <code>TILE_SIZE=32</code> leaves 8 pixels of clearance per side, letting the player slip through 1-tile-wide corridors and doorways.",
          
          "<blockquote>This is a common 2D game trick ‚Äî make the collision box slightly smaller than the grid to forgive near-misses.</blockquote>",
          
          "<strong>How I used AI:</strong> AI kept Player independent of Room and GameState by passing <code>wall_rects</code> as a parameter ‚Äî making Player reusable in any context. Every code section includes block comments explaining concepts, not just syntax. AI identified the key bind conflict where arrow keys moved the player and switched rooms simultaneously. The <code>spawn_point</code> system built in the bonus phase paid off immediately via <code>Player(*room.spawn_point)</code>. Delta time from Session 1 powered frame-rate independent movement: speed in pixels/second, not pixels/frame."
        ]
      }
    ]
  }
}
